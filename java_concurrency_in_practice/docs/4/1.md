---
layout: post
title: 《Java并发编程实战》4.对象的组合（上）
tags:
  - 读书笔记
categories:
  - 《Java并发编程实战》读书笔记
abbrlink: 49305a06
date: 2020-04-01 22:31:41
---





![img](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200522215258.jpg)

- {% post_link 读书笔记/java并发编程实战/本书章节内容概述 回到导航 %} 
- {% post_link 读书笔记/java并发编程实战/4/1 对象的组合（上） %} 
- {% post_link 读书笔记/java并发编程实战/4/2 对象的组合（中） %} 
- {% post_link 读书笔记/java并发编程实战/4/3 对象的组合（下） %} 

<!-- more -->	



> 本章主要是将一些现有的线程安全组件**组合**为更规模的组件或程。所以会用到**组合模式**，这些模式能够使一个类更容易成为**线程安全**的。并且在维护这些类的时候不会无意破坏类的安全性。
> 

目前为止，已经介绍了关于**线程安全性**与**同步**的一些**基础知识**。然而 我们并**不希望**对每一次**内存访问**都进行分析以确保是**线程安全**的。【因为这太麻烦了】 而是希望将一些**现有的 线程安全 的类**，`组合`为更大规模的组件或程序。

本章将介绍一些 **组合模式**，这些模式能够**使一个类更容易成为`线程安全`的类**，并且在**维护这些类**时不会无意中破坏**类的安全性保证**。



### 4.1 设计线程安全的类

在**线程安全**的程序中，虽然可以将**程序的所有状态**都保存在**`公有静态域`**中，但与那些将**「状态」 封装**起来的程序相比【将类中的**变量**使用 `private` 修饰，或者直接将其封装在方法中】，将**状态**保存在**公有静态域**中的程序的**线程安全性**更`难以得到验证`【无法确保类的线程安全性】。

通过使用 **`封装`** 技术，可以使得在**不对整个程序进行分析的情况下，就可以判断一个类是否是线程安全的**。**【因为 被`private` 修饰的私有变量只有在当前类中可以使用，所以变量的访问路径是确定的。】**

> 在**设计`线程安全的类`**的过程中，需要包含以下 **`三个` 基本要素 **：
>
> - 找出构成**对象`状态`**的**所有变量**。
> - 找出`约束状态`变量的**不变性条件**。
> - 建立**对象状态**的**`并发访问管理策略`**。
>

**【通过读这本书，我才明白了OOP 三大特性中 封装的重要性，之前认为封装只是为了更加内聚，同时屏蔽不重要的细节，并且可以修改通用接口的实现而不影响使用接口的人，读了这本书则明白了`封装在线程安全性与并发中的重要作用`。】**

要分析对象状态，首先从对象的 **域** 开始。如果对象中所有的 **域** 都是`基本类型`的变量，那么这些 **域** 将构成对象的**全部状态**。

`程序清单 4-1` 中的 `Counter` 只有一个域 `value` ，因此这个域是 `Counter` 类的**全部状态**。 **对于含有 n 个基本类型域的对象，其状态就是这些域构成的 n元组。** 

**例如： 二维点的状态就是它的坐标值（x,y) 。**如果在**对象的域中引用了其他对象**，那么该对象的状态将`包含`**被引用的对象的域**。**【也就是对象的嵌套扩展了对象的状态】**

**例如： `LinkedList` 的状态就包括`链表`中所有`节点对象`的状态。**

> `程序清单 4-1` 使用 **Java 监视器模式**的线程安全计数器

```java
// 简单的线程安全类，使用 Java 监视器模式（也就是使用 synchronized 锁来保证线程安全性）
// Counter.java
@ThreadSafe
public class Counter {
    @GuardedBy("this")
    private long value = 0;

    // 保证 value 的可见性
    public synchronized long getValue() {
        return value;
    }

    // 保证 ++value 成为一组原子操作
    public synchronized long increment() {
        if (value == Long.MAX_VALUE) {
            throw new IllegalArgumentException("counter Over flow");
        }
        return ++value;
    }
}
```

**【上面这个例子实现线程安全的途径很简单，其状态是私有的，其他类想要访问需要通过 `getValue`() 方法，而这个方法又被 `synchronized` 修饰，这就实现了线程安全，同一时间 只有一个线程能访问和修改这个变量。】**

**`同步策略`（Synchronization Policy）**定义了如何在不违背**对象不变条件** 或**后验条件**的情况下对其状态的访问操作进行`协同`。 **同步策略**规定了如何将 「**不可变性**」，「**线程封闭**」，与「**加锁机制**」等**结合起来以维护线程的安全性**，并且还**规定了哪些变量由哪些锁来保护**。 

要确保开发人员可以对这个类进行分析与维护，就必须**将同步策略写为正式文档**。**【要维护并发策略，保证类的封装性与同步性不在后续中被破坏，就得依靠文档进行系统的说明】**

#### 4.1.1 收集同步需求

要确保`类`的**线程安全性**，就要确保它的**`不变性条件`不会在`并发访问`的情况下被`破坏`**，这就需要对其状态就行推断。对象与变量都有一个 **状态空间**，即所有可能的取值。**状态空间越小，就越容易判断线程的状态**。 **`final` 类型的域使用的越多，就越能简化对象可能状态的分析过程。**（在**极端情况中，不可变对象只有唯一的状态**，所以不可变对象的状态分析很简单,或者说不需要分析）**【不可变的字段越多，其状态就越简单】**

在许多类中都定义了一些 **不可变条件**， 用于判断状态是有效还是无效的。例如 `Counter` 中的 `value` 域 是 `long` 类型的变量，其状态空间的范围是 `Long.MIN_VALUE` 到 `Long.MAX_VALUE`，但是 `Counter` 中 `value` 域的**取值范围上存在着一个限制，即 不能是负值**（大于等于0）。【**有效值验证条件**】

同样，在操作中还会包含一些**`后验条件`（PostCondition)** 来判断**状态的迁移**是否是有效的【例如使用 `assert` 断言来保证程序执行后字段的变量和预想中的保持一致】。 如果`Counter` 的当前状态是`17`，则下一个有效状态只能是`18`。当**下一个状态需要`依赖`当前状态时，这个操作就必须是一个`复合操作`** **【读取—修改—写入】**。 **并非所有的操作状态都会在状态转换上增加限制**。 例如：当**更新一个保存当前温度的变量时，该变量之前的状态并不会影响计算结果**。【存在状态迁移时没有后验逻辑的操作，比如温度的记录】

由于**`不变性条件`**以及**`后验条件`**在**状态以及状态转换**上施加了各种**约束**，因此就需要**额外的** **同步与封装**。如果某些**状态是无效**的，那么**必须对底层的状态变量进行封装**，否则客户代码可能会使对象处于无效状态。

> 如果某些**状态是无效**的，那么**必须对`底层的状态变量`进行`封装`**，否则客户代码可能会使对象处于无效状态。
>
>  If certain states are invalid, then **the underlying state variables must be encapsulated**, otherwise client code could put the object into an `invalid state.` 
>
> 这里这句话我之前一直没看明白，第二遍看的时候把原文找出来对照着看了下，大概明白什么意思了，如果某个状态是非法的，那么类中的底层变量必须被**封装起来**，**不能随意被客户端访问**，否则就有可能导致无效客户端直接操作该状态从而产生异常状态。

**如果某个操作中存在无效的状态转换，那么该操作必须是原子的**。另外如果类中没有施加这些约束，那么就可以放宽**封装性**或**序列化**等需求，以便获得更高的**灵活性**或**性能**。【理论的信息量比较大，但是没有具体的例子，还需要反复咀嚼消化】

在类中也可以包含**同时约束`多个` 状态变量 的不变性条件**。在一个表示数值范围的类（例如`程序清单 4-10` 中的 `NumberRange`） 中可以包含**两个状态变量**，分别表示范围的**上界和下界**。**这些变量必须遵循的约束是：下界值应该小于等于上界值。**

类似这种包含多个变量的不变性将带来**原子性需求**： 这些相关的变量必须在**单个原子操作中进行读取或更新**。不能首先更新一个变量，然后释放锁并在此获得锁，然后再更新其他变量。【这种操作是错误的，没法保证操作的原子性】 因为**释放锁后，可能会使对象处于 无效状态**。【其他线程将状态的变量修改成了一个错误的值，即为无效状态】**如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。**【重点在于 持有**同一把锁**】

> 如果不了对象的**`不变性条件`**与**`后验条件`**，那么就**不能确保线程安全性。**
>
> 要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于 **原子性**与**封装性**。



#### 4.1.2 依赖状态的操作

类的**不变性条件**与**后验证**约束了在对象上哪些状态和状态转换是有效的。在某些对象的方法中还包含了一些基于状态的先验条件（Precondition）。

例如：不能从空队列中移除一个元素，在删除元素前，队列必须处于非空状态。**如果某个操作中包含有基于`状态`的先验条件，那么这个操作就称为`依赖状态`的操作。**

在**单线程程序**中，如果某个操作无法满足先验条件，那么就只能失败。但在**并发程序**中，先验条件可能会由于**其他线程**执行的操作而导致其状态为真。在**并发程序**中要一直等到先验条件为真，然后再执行该操作。

在`Java`中，等待某个条件为真的各种 「**内置机制**」（包括**`等待`和`通知`**等机制）都与**内置加锁机制**紧密关联，要想**正确**使用它们并不容易。要想实现某个等待先验条件为真实才能执行的操作，一种更简单的方法是通过现有库中的类（例如 **阻塞队列[**`Blocking Queue`] 或 **信号量** [`Semaphore`] 来实现**依赖状态**的行为。）第 [14章]()将介绍如何使用在**平台与类库**中提供的各种**底层机制**来**创建依赖状态的类**。

#### 4.1.3 状态的所有权

[4.1](#4.1 设计线程安全的类)节 曾指出，如果以某个对象为根节点构造一张对象图，那么该**对象的状态将是对象图中所有对象包含的域的一个子集**。为什么是"`子集`"？  **在对象可以到达的所有域中，需要满足哪些条件才`不属于` 对象状态的一部分。**

在定义哪些**变量**将构成**对象的状态**时，只考虑**对象拥有的数据**。 `所有权`（**Ownership**）在 `Java` 中并**没有**得到充分的提现，而是属于**`类设计`**中的一个要素。

如果**分配并填充**了一个 `HashMap`对象，那么就**相当于创建了多个对象**：

- `HashMap` 对象**本身**
- 在 `HashMap` 对象中**包含的对象**（容器中的内容）
- 以及在 `Map.Entry` 中可能**包含的内部对象**。

`HashMap` 对象的**逻辑状态**包括**所有的**「 `Map.Entry` 对象」以及「**内部对象**」，即使这些对象都是一些**独立**的对象。

无论如何，**垃圾回收机制**使我们**避免**了如何处理**所有权**这个问题。在 `C++` 中，当**把一个对象传递给某个方法**时，必须认真考虑这种操作是否**传递对象的所有权**，是短期的所有权还是长期的所有权。  `Java` 中同样存在这些**所有权模型**，只不过**垃圾回收器**为我们减少了许多在**`引用共享`**方面常见的错误，因此降低了在所有权处理上的开销。【这一部分应该要结合《深入理解JVM》中的垃圾回收器部分来学习。】

许多情况下，**所有权**与**封装性**总是**相互关联**的**：对象封装它拥有的状态，反之，对象拥有它封装状态的所有权。**  **状态变量**的所有者将决定采用何种加`锁`协议来维持变量状态的完整性。 **所有权意味着控制权**。

然而，如果**发布**了某个**可变对象**的**引用**，那么就不再拥有**独占**的控制权，顶多是"**共享控制权**"。 对于从**构造函数**或者从**方法中传递进来的对象**，类通常并**不拥有**这些对象，**除非这些方法是被专门设计**为 转移传递进来的对象的所有权（例如，**同步容器封装器的工厂方法**）。

**容器类**通常表现出一种"**`所有权分离`**"的形式，其中**容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态**。【这句话很精髓，记住并理解。】

 `Serlvet` 框架中的 `ServletContext` 就是其中一个示例：

- `ServletContext` 为 `Servlet` 提供了 类似 `Map` 形式的**对象容器**服务，在 `ServletContext` 中可以通过名称来注册（`setArrtibute`)或通过名称获取（`getArrtibute`）**应用程序对象**。 由 `Servlet` 容器实现的 `ServletContext` 对象必须是**线程安全**的，因为它**肯定会被多个线程同时访问**。当调用`setAttribute` 和 `getAttribute` 时，`Servlet` 不需要使用同步，但当使用保存在 `ServletContext` 中的对象时，则可能需要使用同步。**这些对象由应用程序拥有，`Servlet` 容器只是替应用程序保管它们。**

与所有**共享对象**一样，**它们必须安全地被共享**。为了防止多个线程在`并发`访问**同一个对象**时产生相互干扰，**这些对象应该是：**

- 其本身是**线程安全**的对象
- **事实不可变**的对象
- 或者由**锁**来保护的对象。**①**

↑【共享对象在多线程情况下的3种安全的情况】

> **注解①：**需要注意的是，虽然 `HttpSession` 对象在功能上类似于 `Servlet` 框架，但是可能`HttpSession` 有着**更严格的要求**。由于 `Servlet` 容器可能需要访问 `HttpSession` 中的对象，以便在**赋值操作**或者**钝化操作** （**Passivation** 指的是**将状态保存到持久性存储**【那感觉跟持久化是一个意思】）中对它们序列化，因此这些对象 **必须** 是**线程安全**的。因为容器可能与 `WebApplication` 程序同时访问它们。（之所以说"可能"，是因为在 Servlet 规范中并没有明确定义 复制与钝化 等操作，这只是大多数 Servlet 容器的一个常见功能）。

### 4.2 实例封闭

如果某对象**不是线程安全**的，那么可以**通过多种技术使其在多线程程序中安全地使用**:

- **确保该对象只能由单个线程访问（线程封闭）**
- 通过一个`锁`来保护该对象的所有访问



**【也就是即使对象本身并非线程安全，依旧可以通过外部手段在多线程环境下使用这个对象】**

**`封装`简化了线程安全类的实现过程，它提供了一种`实例封闭机制`（Instance Confinement），通常也`简称`为封闭（CPJ 2.3.3）。** 当**一个对象被封装到另一个对象中**时，能够**访问被封装对象的所有`代码路径都是已知`的**。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将**封闭机制**与合适的 **锁策略** 结合起来，可以确保**以线程安全的方式来使用非线程安全的对象**。

![image-20200605211456975](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200605211507.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200605211603.png)

【**`问题`**：之前的访问路径是**整个应用程序 —> 被封装类的状态**，现在的访问路径是 **整个应用程序 —> 封装类 —> 被封装类的状态**，**虽然能确定是从封装类中访问的，但是封装类还是能被整个应用程序访问的**，突然迷惑了。】

> 将**数据封装在对象内部，可以`将数据的访问限制在对象的方法上`**，从而更容易确保线程在访问数据时总能持有**正确的锁**。
>
> 【持有正确的锁的重要性】

**被封闭的对象一定不能超出它们既定的作用域**。  对象可以**封闭在类的一个实例**中（例如作为类的一个私有成员），或者**封闭在某个作用域**内（例如作为一个 方法的「`局部变量`」），再或者**封闭在线程内**（例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程中共享该对象）。 **对象本身不会逸出—**—出现逸出的情况通常由于开发人员在发布对象时超出了对象的既定作用域。 **【对象不会主动逸出，出问题就是人为的操作不当，将对象发布出了作用域】**

**程序清单 4-2** 中的 `PersonSet` 说明了如何通过**封闭与加锁**等机制使一个类成为**线程安全**的（即使这个类的状态变量并不是线程安全的）。

`PersonSet` 的状态由 `HashSet` 来管理，而 `HashSet` 并非是线程安全的，由于 `mySet` 是**私有的并且不会逸出**，因此 `HashSet` 被**封闭**在 `PersonSet` 中。 

唯一能访问 `mySet` 的代码路径是 `addPerson` 和 `containPerson`，在执行它们时都要获得 `PersonSet` 上的锁。 `PersonSet` 的状态完全由它的内置锁保护，因而 `PersonSet` 是一个线程安全的类。

> 程序清单 4-2 通过封闭机制来确保线程安全 ：

```java
// 使用线程封闭来确保线程的安全性 本类并不是一个线程安全的类，但是通过线程封闭与内置锁保证了在多线程环境下使用本类的线程安全性
// PersonSet.java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set<Person> mySet = new HashSet<>();

    public synchronized void addPerson(Person person) {
        mySet.add(person);
    }

    public synchronized boolean containPerson(Person p) {
        return mySet.contains(p);
    }


    interface Person {
    }
}

```

这个示例中并未对 `Person` 类的线程安全性做任何假设，但如果 `Person` 类是**可变**的，那么在访问从 `PersonSet` 中获得的 `Person`对象时，还需要**额外的同步**。 要想**安全**地使用`Person` 对象，最可靠的方法就是使 `Person` 成为一个线程安全的类。

另外也可以使用**锁**来保护 `Person` 对象，并确保所有**客户代码**在访问 `Person` 对象**之前**都已经获取了**正确的锁**。

【怎样确定什么是正确的锁呢？如果获取了错误的锁是否不能达成线程安全性的目的？】

**实例封闭**是构建线程安全类的一个最简单的方式，它还使得在**锁策略**的选择上拥有更多的**灵活性**。

在 `PersonSet` 中使用了它的**内置锁**来保护它的状态，但对于其他形式的锁来说，只要自始至终都是 **同一个锁**，就可以保护状态。 

**实例封闭**还使得**不同的状态变量可以由不同的锁来保护**（后面章节的 `ServerStatus` 中就使用了多个锁来保护类的状态）

在 J**ava 平台中的类库(JDK）**中还有很多**线程封闭**的示例，其中有些类的 唯一用途 就是**将非线程安全的类转化为线程安全的类**。一些基**本的容器类是`非线程安全`的**，例如 `ArrayList` 和 `HashMap` ，但类库提供了**包装器工厂方法**（例如 `Collections.syncrhonizedList` 及其类似方法），可以让这些**非线程安全**的类在多**线程环境**中**安全**地使用。

**下图↓：将非线程安全的类使用内置锁转化为线程安全的类的工厂方法：**

![image-20200605220925713](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200605220926.png)

![image-20200605221033441](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200605221034.png)

这个**线程安全的`List`**中的方法对状态进行访问时都需要获得同一把锁 `mutex`。

这些工厂方法通过"**装饰器**（`Decorator`）"设计模式将**容器类**  **封装** 在一个同步的`包装器对象`中，而`包装器`能将接口中的每个方法都实现为 同步方法，并将调用请求**转发**到**底层**的**容器对象**上。 

只要**包装器对象**拥有对**底层对象**的**`唯一引用`**（将底层对象封闭在包装器中），那么它就是**线程安全**的。 在这些方法的 `javadoc` 中指出，**对底层容器对象所有访问都必须通过包装器来进行**。

如果**将一个本该被封闭的对象发布出去，也能`破坏`封闭性**。【之前章节中的逸出就是描述这种情况的】

如果一个对象本应该被封闭在特定的作用域内，那么让该对象`逸出`作用域就是一个`错误`。当发布其他对象时，例如迭代器或内部的类实例，可能会**间接地发布**被封闭的对象，同样会使被封闭对象逸出。【比如内部类中的 `this` 引用逸出清理】

**封闭机制**更容易构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查**整个程序**。（封装的重要意义。）

#### 4.2.1 Java 监视器模式

从**线程封闭原则**及其逻辑推论可以得出 — **Java 监视器模式**①。 遵循 Java 监视器模式的对象会把所有对象的可变状态都封装起来，并由自己的内置锁来进行保护。

> **注解①** ： **Java监视器模式**： 来自于 Hoare 对监视器机制的研究工作（Hoare，1974），但这种模式与真正的监视器类之间存在一些**重要的差异**。进入和退出同步代码块的字节指定也称为 monitorentter 和 monitorexit，而 Java 的内置锁也称为 监视器锁或监视器。



在`程序清单 4-1` 的 `Counter` 中给出了这种模式的一个**典型示例**：在 `Counter` 中封装了一个状态变量 `value` ，对该变量的所有访问都需要通过 `Counter` 中的方法来执行，并且这些方法都是由**内置锁**保护的。

在许多类中都使用了 `Java` **监视器模式**，例如 `Vector` 和 `Hashtable` 。在某些情况下，程序需要使用一种更复杂的同步策略。 **第11 章** 将介绍如何通过 **细粒度的加锁策略** 提高`可伸缩性`。 **Java 监视器模式的主要优势就在于它的简单性。**

**Java 监视器模式**仅仅是一种编写代码的**约定**，**对于任何一种锁对象，只要自始至终都使用`同样的锁对象`，都可以用来保护对象的状态。**

> `程序清单 4-3` 给出了如何使用 **`私有锁`** 来保护状态：

```java
// 通过私有对象作为锁保护对象的状态
// PrivateLock.java
public class PrivateLock {
    // 一个私有的对象，将这个对象作为一把锁
    private final Object myLock = new Object();

    @GuardedBy("myLock")
    Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // 访问或修改 widget 的状态
        }
    }
}

```

使用**私有锁对象**而不是对象的内置锁（或任何其他可通过公有方式访问的锁），是因为私**有锁有许多优点**：

- **私有的锁对象可以将锁封装起来**，使客户代码无法得到锁，但客户代码可以通过公有方式来访问锁。以便（正确或不正确地）参与到它的同步策略中。 

如果客户代码**错误地获得了`另一个对象`的锁**，那么可能会产生**活跃性问题**。 此外，要想`验证`某个**公有访问**的锁在程序中是否被正确地使用，则**需要检查整个程序，而不是单个的类**。【还是封装的重要意义，将检查的范围缩小到了所封装的类中，而不是在整个程序中】

#### 4.2.2 示例：车辆追踪

**`程序清单 4-1`**  中的 `Counter` 是一个简单但用处不大的 **Java 监视器模式**示例。

下面是一个更具有实际意义的例子：一个用于**调度车辆的车辆追踪器**。例如出租车、警车、货车等。

首先使用 **监视器模式**来构建车辆追踪器，然后再**尝试放宽某些封装性需求同时又保持线程的安全性**。

每台车都由一个 `String` 对象来标识，并拥有一个相应的**位置坐标(x,y)**。 在 `VehicleTracker` 类中封装了车辆的标识和位置，因而它非常适合作为**基于 MVC 模式**的 GUI 应用程序中的 **View  数据模型**。

并且该模型将由一个**视图线程**和多个**执行更新操作的线程**共享。 **视图线程会读取车辆的名字和位置**，并将它们显示在界面上：

```java
// 视图线程，返回当前数据的快照
Map<String,Point> locations = vehicles.getLocations();
for(String key : locations.keySet()) {
		renderVehicle(key,locations.get(key));
}
```



类似地，**执行更新操作的线程**通过 GPS设备上获取的数据或者调度员从 GUI 界面上输入的数据来修改车辆的位置：

```java
// 执行数据更新操作的线程
void vehicleMoved(VehicleMovedEvet evet) {
		Point loc = evt.getNewLocation();
  	// 根据车辆ID，更新对应的车辆位置坐标
		vehicles.setLocaltion(evt.getVehicleId,loc.x,loc.y);
}
```

**视图线程**与执行更新操作的线程 **并发地访问数据模型**，因此**该模型必须是线程安全的**。 **`程序清单 4-4`**  给出了一个基于 **Java 监视器模式**来实现的 "车辆追踪器"，其中使用了**`程序清单 4-5`** 中的 `MutablePoint` 来表示车辆的位置。

> `程序清单 4-4` 基于**监视器模式**的车辆追踪

```java
// 一个车辆追踪类，可能在多线程环境下对同一个车辆的位置信息进行读取和修改
@ThreadSafe
public class MonitorVehicleTracker {
  	// 使用一个被 final 修饰的 Map 来保存车辆的位置信息，获取其中保存的对象时，首先需要获得对应的锁
    @GuardedBy("this")
    private final Map<String, MutablePoint> locations;

    /**
     * 构造 车辆位置信息追踪系统，注意这里没有直接将传入构造函数中的引用赋值给类中的引用，而是经过处理后返回了一个 unmodifiableMap
     *
     * @param locations
     */
    public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }

    /**
     * 根据 车辆的ID 获取 车辆当前的位置信息
     *
     * @param id
     * @return
     */
    public synchronized MutablePoint getLocation(String id) {
        MutablePoint location = locations.get(id);
        //这里返回的是一个新的 MutablePoint ，所以不会存在导致其本身的引用逸出的问题
        return location == null ? null : new MutablePoint(location);
    }

    /**
     * 更新 指定车辆的位置 由于可能多个线程同时更新一辆车的位置信息，所以该方法需要是线程安全的。
     *
     * @param id
     * @param x
     * @param y
     */
    public synchronized void setLocations(String id, int x, int y) {
        MutablePoint location = locations.get(id);
        if (location == null) {
            throw new IllegalArgumentException("No such Id Car:" + id);
        }
        location.x = x;
        location.y = y;
    }

		// 这个方法很重要，为了防止引用的泄漏，所以返回的是 一个拷贝的 不可变 Map
    private Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<>();

        for (String id : m.keySet()) {
            result.put(id, new MutablePoint(m.get(id)));
        }
        // 返回一个不不可变的 Map
        return Collections.unmodifiableMap(result);
    }
}

```

虽然类 `MutablePoint`（保存具体数据的Bean) **不是线程安全**的，但是**追踪器类是线程安全**的。 它所包含的 `Map` 对象 和**可变的 `Point` 对象**都没有发布【被封装在追踪器类内】。当需要返回车辆的位置时，通过 `MutablePoint` **拷贝构造函数**或者 `deepCopy` 方法来**复制正确的值**，从而**生成一个`新的`** `Map` 对象，并且**该对象中的值与原有的 Map 对象中的 key 和 value 都相同。①**

①：注意，`deepCopy` **并不只**是用 `unmodifiableMap` 来包装 `Map`的，因为这**只能防止容器对象被修改**，而**不能防止调用者修改保存在容器中的可变对象**。 基于同样的原因，如果只是通过拷贝构造函数来填充`deepCopy` 中的 `HashMap`，那么**同样是`不正确`的**，因为这只是复制了 `Point` 对象的**引用**，而不是 `Point` **对象本身**。 



**这里的操作细节挺多的，来梳理一下：**

> **1、**首先**定义数据模型**，一个很简单的类 `MutablePoint`，该类包含**2个可变的状态**，`int x,y`。 代表了车辆的位置。
>
> **2、**`MonitorVehicleTracker`追踪器将 `MultablePoint` **封装在了类中**，使用 `private` 和 `final` 对其进行修饰，**private 保证了只能通过方法来访问该数据类，final则保证了这个引用不能再指向别的 Map，虽然其中保存的对象仍然是可变的。**

 ```java
  private final Map<String, MutablePoint> locations;
 ```

> **3、**其他线程想要`获得车辆位置`，则只能调用 `getLocation` 方法，**这个方法是线程安全的**，因为它被 `synchronized` 修饰，所以**`同一时间只有一个线程`可以获取某车辆的位置，并且获取到的是一个`新的` `MutablePoint` 对象，`而不是直接从 Map 中获得的原始的对象`。**

```java
 public synchronized MutablePoint getLocation(String id) {
        MutablePoint location = locations.get(id);
        //这里返回的是一个新的 MutablePoint ，所以不会存在导致其本身的引用逸出的问题
        return location == null ? null : new MutablePoint(location);
    }
```

> 4、**`初始化`监视器数据**时，需要初始化所有车辆的位置，这里这个初始化的方法挺讲究的：
>
> - 初始化车辆监视器需要传入一个 `Map`，其中包含了当前所有车辆的位置。
> - 这个 `Map` **没有直接被赋值**给封装在监视器中用来保存车辆位置的 `Map locations`，而是经过了**2道处理流程**才赋值给 `locations`。
> - 处理流程1、：新创建一个`Map`，同时`遍历`传入`Map`，并`构造新的数据对象`，将其放入新创建的 `Map` 中 ——> 这个操作的目的：防止`容器中保存的`「**`可变对象`**」被修改。
> - 处理流程2、：使用 `Collections.unmodifiableMap`对新创建的 `Map` 进行处理，返回一个不可变的Map ——> 这个操作的目的：「**防止`容器对象本身`被修改**」
> - 将  `Collections.unmodifiableMap` 返回的不可变 Map 赋值给 locations，数据的初始化此时才完成。

```java
// 这个方法很重要，为了防止引用的泄漏，所以返回的是 一个拷贝的 不可变 Map
    private Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<>();

        for (String id : m.keySet()) {
            result.put(id, new MutablePoint(m.get(id)));
        }
        // 返回一个不不可变的 Map
        return Collections.unmodifiableMap(result);
    }
```

> **`程序清单 4-5`** 与 Java.awt.Point 类似的**可变 `Point `类**（线程不安全，不要这么做）：

```java
// 类似 java.awt.Point 一个封装了 x,y 2个int值的可变的类 非线程安全
// MutablePoint.java
public class MutablePoint {
    public int x, y;

    public MutablePoint() {
        this.x = 0;
        this.y = 0;
    }

    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}

```

之前例子中维持这个可变数据模型的**线程安全**的方法是：**在返回客户代码之前复制可变的数据来维持线程的安全性。**【也就是返回的是一个`视图`，每次返回都重新 `new` 了一个 `MutablePoint` 类的`实例`。】

 通常情况下，这并不存在 **性能问题**，但在 **`车辆容器非常大`**的情况下将**`极大地降低性能`**。 由于 `deepCopy` 是从 `synchronized` 方法中调用的，因此在**执行时间较长**的复制操作中，`tracker` 的**内置锁将一直被某线程占有**，当有**大量**车辆需要追踪的时候，会**严重降低用户界面的响应灵敏度**。【初始化需要的时间很长，导致锁一直被占用，其他操作无法执行。】

此外，由于每次调用 `getLocation` 就要**`复制数据`**，**因此将出现一种错误情况 —— 虽然车辆的实际位置发生了变化，但是返回的信息却保持不变。** 【**这种情况出现的原因是**：获取对象时需要持有锁，而此时这个车辆发生了变化，更新数据也需要持有锁，而此时这把锁被获取对象的线程持有，所以这个线程获取到的是一个旧的位置信息，当它获取完毕并将锁释放后，更新线程才能获取到锁并更新车辆的位置】

这种情况的**`利弊`**根据你的**`需求`**而定：**如果在 `location` 集合上存在`内部的一致性需求`，那么这就是`优点`，在这种情况下`返回一致的快照`就非常重要**。 

然而如果**调用者**需要每辆车的**`最新信息`**，那么这就是**缺点**，因为这需要非常**频繁地刷新快照**。**【而这将带来性能开销和内存的开销。】** 

