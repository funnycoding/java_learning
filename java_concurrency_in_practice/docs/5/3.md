---
layout: post
title: 《Java并发编程实战》5.基础构建模块 （三） 阻塞队列与 生产者—消费者模式
tags:
  - 读书笔记
categories:
  - 《Java并发编程实战》读书笔记
abbrlink: 43d7b066
date: 2020-04-08 11:58:31
---

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200408180330.png)

**因为第五章非常长，所以我按小节进行了切分：**

- {% post_link 读书笔记/java并发编程实战/5/1.同步容器类 1.同步容器类 %} 

- {% post_link 读书笔记/java并发编程实战/5/2.并发容器 2.并发容器 %}

- {% post_link 读书笔记/java并发编程实战/5/3 3.阻塞队列和生产者 — 消费者模式 %}

- {% post_link 读书笔记/java并发编程实战/5/4 4.阻塞方法与中断方法 %}

- {% post_link 读书笔记/java并发编程实战/5/5 5.同步工具类 %}

- {% post_link 读书笔记/java并发编程实战/5/6  6.构建高效且可伸缩的缓存结果 %}

<!-- more -->

### 5.3 阻塞队列和生产者 — 消费者模式

**「阻塞队列」**提供了**可阻塞**的 `put` 和 `take` 方法，以及支持**定时**的 `offer` 和 `poll` 方法。 如果队列已经满了，那么 `put` 方法将阻塞直到有空间可用； 如果队列为空，那么 `take` 方法将阻塞 直到有元素可取。



**「队列可以是有界的也可以是无界的」**，无界队列永远都不会被填充满，因此 **无界队列上的 put 方法永远不会阻塞。**

`阻塞队列`支持 "**生产者——消费者**" 这种**「设计模式」**，该模式将 "找出需要完成的工作" 与 "执行工作" 这两个过程分离开，并把工作项放入一个 "待完成" 列表中以便在随后处理，而不是找出后 立即处理。

**"`生产者——消费者`"** 模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性【解耦】，此外该模式还将**「生产数据的过程」**与**「使用数据的过程」** 「解耦」 以简化 **「工作负载」** 的管理，因为生产和消费 这两个过程在处理数据的速率上有所不同。

**在基于 阻塞队列 构建的 "生产者——消费者" 设计中，当数据生成时，生产者把数据放入队列，当消费者准备处理数据时，从队列中获取数据。** **<---【生产者—消费者 的构建 基于 「阻塞队列」】**

生产者不需要知道消费者的标识或数量，或者它们是否是唯一的生产者，它们只需要将数据放入队列即可。

同样 ，消费者也不需要知道生产者是谁，或者工作来自何处，只需要从队列中取出数据进行处理即可。

`BlockingQueue` 简化了 "生产者——消费者" 设计的实现过程，它支持任意数量的生产者和消费者。一种最常见的 "生产者——消费者" 模式就是 **「线程池与工作队列的组合」，在 Excutor 任务执行框架中就体现出了这种模式，这也是 [第6章]() 和 [第8章]() 的主题。**  **<--- 【典型应用】**

以两个人洗盘子为例，二者的劳动分工也是一种 "生产者——消费者" 模式：

- 其中一个人把洗好的盘子放在盘架上，而另一个人从盘架上取出盘子并将它们烘干。

在这个例子中，盘架相当于 「阻塞队列」，如果盘架上没有盘子，那么消费者会一直等待，直到有盘子需要烘干。 如果盘架放满了，那么生产者会停止清洗，直到盘架上又空间来摆放盘子。

我们可以将这种类比扩展为 多个生产者（虽然可能存在对 「水槽」 的竞争） 和多个消费者，每个工人只需要与盘架打交道。人们不需要知道究竟有多少 生产者 或 消费者，或者谁生产了某个指定的工作项。

"生产者" 和 "消费者" 的角色是**相对的**，某种环境中的消费者在另一种不同的环境中可能成为生产者。

烘干盘子的工人将"消费" 洗干净的湿盘子，从而生产烘干的盘子。第三个人把洗干净的盘子整理好，在这种情况中，烘干盘子的人既是消费者，也是生产者，从而就有了两个共享的工作队列。（每个队列都可能阻塞 烘干 工作的运行）。

阻塞队列「简化」了**消费者程序的编码**【通过数据结构的特性，减少了逻辑代码的编写】，因为 take 操作会一直阻塞到有可用的数据。

如果生产者不能尽快地产生工作项，使消费者保持忙碌，那么消费者就只能一直等待，直到有工作可做。

在某些情况下，这种方式是非常合适的（例如在服务器应用程序中，没有任何客户请求服务时，则一直闲置），而在其他一些情况下，也表示需要调整生产者线程数量和消费者线程数量之间的比率，从而实现更高的资源利用率。（例如：爬虫 WebCrawler 或其他应用程序中，有无穷的工作需要完成）

如果生产者完成工作的速率比消费者处理工作的速率快，那么工作项会在队列中积累起来，最终 耗尽内存。 同样，put 方法的阻塞特性也极大地简化了生产者的编码。如果使用 「有界队列」，那么当队列充满时，生产者将阻塞并且不能继续工作，而消费者就有时间来赶上工作处理进度。

阻塞队列同样提供了一个 `offer` 方法，如果数据项不能被添加到 队列中，那么将返回一个 失败 状态。 

这样你就能够创建更多的灵活策略来处理负荷过载的情况，例如：

- 减轻负载
- 将多余的工作项序列化并写入磁盘
- 减少生产者线程数量
- 通过某种方式来抑制生产者线程

> 在构建「高可靠」的应用程序时，有界队列是一种强大的「资源管理工具」：它们能抑制并防止产生过多的工作项，使应用程序在「过载」的情况下变得更加「健壮」。

虽然 "**生产者——消费者**" 模式能够将 生产者和消费者之间的代码**通过队列进行解耦**，但是它们的行为仍然也会通过共享工作队列**间接的耦合**在一起。 **【解决了直接耦合，产生了间接耦合。】**

开发人员总会假设消费者处理工作的速率能赶上生产者生成工作项的速率，因此通常不会为工作队列的大小设置 边界。 但这将导致之后需要重新设计系统架构。**【因为生产速率和消费速率可能并不如我们设想的那样，所以需要从设计层面来认真考虑是否需要引入 阻塞队列 并明确设置其边界大小】**

因此应该尽早地通过阻塞队列在设计中构建资源管理机制 —— 这就事儿做的越早，就越容易。在许多情况下，「阻塞队列」能使这项工作更加简单，如果阻塞队列不完全符合设计需求，那么还可以通过 「信号量」`Semaphore` 来创建其他的 「阻塞数据结构」。参见 [5.5.3节](#5.5.3 信号量)。

在类库中包含了 `BlockingQueue` 的多种实现，其中 `LinkedBlockingQueue` 和 `ArrayBlockingQueue` 是 FIFO 队列【先进先出】，二者分别与 LinkedList 和 ArrayList 类似，但比同步 List 拥有更好的并发性能。

`PriorityBlockingQueue` 是一个按优先级排序的队列，当你希望按照某种顺序而不是 先进先出 来处理元素时，这个队列将非常有用。【比如 VIP 用户的排队插队场景】

正如其他有序的容器一样，`PriorityBlockingQueue`  既可以根据元素的 「自然顺序」 来比较元素（如果它们实现了 `Comparable` 方法），也可以使用 `Comparator` 来比较。 **<----【实现 Comparable 方法与 使用 Comparator 比较的区别？】**

最后一个 `BlockingQueue` 的实现是 `SynchronousQueue` ，实际上它不是一个真正的队列，因为它不会为队列中的元素维护存储空间。与其他队列不同的是，它维护 「一组线程」，这些线程在等待着把元素加入或移出队列。

如果以洗盘子作为比喻，那么`SynchronousQueue` 相当于没有盘架，而是直接将洗好的盘子放入下一个空闲的烘干机中。【也就是没有工作队列，而是多个操作员？】

这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。（在传统的队列中，在一个工作单元可以 交付之前，必须通过 **「串行」** 方式首先完成 入列 **[Enqueue]** 或者出列**[Dequeue]** 等操作） **【也就是跟队列有一个互动，而这种 `SynchronousQueue` 则去掉了队列，没有中间商赚差价？233】**  直接交付方式还会将更多关于人物状态的信息反馈给 「生产者」。 当交付被接受时，它就知道生产者已经得到了任务，而不是简单地把任务放入了一个队列 —— 这种区别就好比将文件直接交给同事，或者是将文件通过邮箱发给同事，并希望她能尽快拿到文件。【一个是及时的，一个是异步的。】

因为 `SynchronousQueue` 没有存储功能，因此 `put` 和 `take` 会一直阻塞**【相当于管道一样？直接把生产者和消费者对接，当有数据产生则直接发送，否则就一直阻塞】**，直到另一个线程已经准备好参与到交付过程中。

仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用**「同步队列」**。 **<---【使用场景，但是光这一句话还是太单一了，我需要对其进行扩充，因为我也没有在实际工作中使用过这种同步队列】**

#### 5.3.1 示例：桌面搜索

有一种类型的程序适合被分解为 生产者 和 消费者，例如 代理程序，它将扫描本地驱动器上的文件并建立索引以便随后进行搜索，类似于某些桌面搜索程序或者 Windows 索引服务。 

在 **程序清单 5-8 ** 的 `DiskCrawler` 中给出了一个生产者任务，即在某个文件层次结构中搜索 符合索引标准的文件，并将它们的文件名 放入 「工作队列」。而且 `Indexer` 中还给出了一个消费者任务，从队列中取出文件名称并对它们建立索引。

> **`程序清单 5-8`** 桌面搜索应用程序中的生产者任务和消费者任务

```java
// 一个关于 桌面搜索程序的对生产者和消费者的应用实例
public class ProducerConsumer {

    /**
     * 用来抓取桌面文件内容的生产者
     */
    static class FileCrawler implements Runnable {
        // 阻塞队列，用于存储要索引的文件
        private final BlockingQueue<File> fileQueue;
        // 文件的过滤器，判断是否要将文件放入队列
        private final FileFilter fileFilter;
        // 具体的被处理的队列中的生产资源，在这个例子中是file
        private final File root;

        public FileCrawler(BlockingQueue<File> fileQueue, FileFilter fileFilter, File root) {
            this.fileQueue = fileQueue;
            this.root = root;
            // 重写了 accept 方法
            this.fileFilter = f -> f.isDirectory() || fileFilter.accept(f);
        }

        // 返回是否已经对文件进行索引，但是这里没有进行判断，直接返回的就是 false
        private boolean alreadyIndexed(File file) {
            return false;
        }

        @Override
        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        /**
         * 将桌面中的所有 文件放入 fileQueue 中
         *
         * @param root
         * @throws InterruptedException
         */
        private void crawl(File root) throws InterruptedException {
            File[] entries = root.listFiles(fileFilter);
            if (entries != null) {
                for (File entry : entries) {
                    if (entry.isDirectory()) {
                        crawl(entry);
                    }
                    // 但是这里 返回的肯定是 false 然后 变成 true 进入 put 逻辑
                    else if (!alreadyIndexed(entry)) {
                        fileQueue.put(entry);
                    }
                }
            }
        }
    }

    // 消费者，获取队列中的元素，这里是文件，然后对其进行索引（方法逻辑未实现，只是列出其逻辑）
    static class Indexer implements Runnable {
        private final BlockingQueue<File> queue;

        public Indexer(BlockingQueue<File> queue) {
            this.queue = queue;
        }


        @Override
        public void run() {
            try {
                while (true) {
                    indexFile(queue.take());
                }
            } catch (InterruptedException e) {
                // 发生异常就使线程停止
                Thread.currentThread().interrupt();
            }
        }

        public void indexFile(File file) {
            // 对文件进行索引编号的方法，这里书中并没有实现具体逻辑
        }
    }

   
}

```

**生产者 — 消费者 模式提供了一种 适合线程的方法将 桌面搜索问题分解为 更简单的组件**。 将 「文件遍历」 与建立索引等功能分解为独立的操作，比将所有功能都放到一个操作中实现有着更高的 「代码可读性」 和 「可重用」性：每个操作只需要完成一个任务，并且阻塞队列将负责所有的控制流，因此每个功能的代码都更加简单清晰。

【也就是将逻辑控制完全交给了阻塞队列，从而使 生产 和 消费 2个动作独立，各自逻辑自己处理，分解成2个独立的块，更加清晰，这部分设计的意图我弄明白了，**这是 生产者—消费者模式在代码设计上带来的好处**】



生产者 — 消费者 模式同样能带来许多**「性能优势」**。 生产者 — 消费者 可以并发地执行。如果一个是 I/O 密集型，另一个是 CPU 密集型，那么并发执行的吞吐率要高于 串行执行的吞吐率。

如果生产者和消费者的「并行度」不同，那么将它们紧密耦合在一起会把整体并行度降低为二者中更小的并行度。

**【↑也就是木桶理论，性能最差的部分决定整个程序的性能】**



在**程序清单 5-9** 中启动了多个爬虫程序和索引建立程序，每个程序都在各自的线程中运行。前面提到过，消费者线程永远不会退出，因而程序无法终止， [第7章]() 将介绍多种技术来解决这个问题。<---【并发中的终止问题】

虽然这个示例使用了 显示管理 的线程，**但许多 生产者—消费者 的设计也可以通过 `Executor` 任务执行框架来实现，其本身使用的也是 生产者 — 消费者模式。** **【 使用线程池 Executor 也间接的使用了 生产者 — 消费者 模式】**

> `程序清单 5-9` 启动桌面搜索

```java
 // 设定队列的界限
    private static final int BOUND = 10;

    // 设置消费者的数量，这里是获取当前运行环境的CPU核心数并将其设置为消费者数量
    private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();

    public static void startIndexing(File[] roots) {
        BlockingQueue<File> queue = new LinkedBlockingQueue<>(BOUND);

        FileFilter filter = pathname -> true;

        // 生产者,将文件放入 queue 中，填充要标记的文件队列
        for (File root : roots) {
            // 每个 roots 分配一个线程用来填充要进行标记的文件队列
            new Thread(new FileCrawler(queue, filter, root)).start();
        }

        // 消费者,消费队列中的文件，对其进行 indexFile() 标记方法
        for (int i = 0; i < N_CONSUMERS; i++) {
            new Thread(new Indexer(queue)).start();
        }
    }
```

**【这里只是对 之前 5-8 的节选，也就是 `startIndexing()` 方法的代码。 所以 5-8，5-9 加起来是一个完整的例子，5-8 是生产者—消费者 2部分的代码，5-9 是启动搜索的代码。 】**

#### 5.3.2 串行线程封闭

在 `java.util.concurrent`  Java 并发包中实现的各种阻塞队列 都包含了足够的 内部同步机制，从而安全地将对象从 「生产者线程」 发布到 「消费者线程」。

对于可变对象， 生产者—消费者 这种设计与阻塞队列一起，促进了**线程封闭**，从而将对象所有权从生产者交付给消费者。 

线程封闭对象只能被单个线程持有，但可以通过安全地 「发布」 该对象来 "转移" 对象的所有权。 在转移所有权之后也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。

这种安全的发布确保了对象状态对于 新的所有者 来说是可见的，并且由于最初的所有者不会再访问它，因此对象被封闭在新的 线程中。

新的所有者线程可以任意对该对象进行修改，因为它具有 独占 的访问权。

「对象池」 利用了 串行线程封闭，将对象 "借给" 一个请求线程。 只要对象池内包含足够的 内部同步 来安全地发布池中的对象，并且只要客户代码本身不会发布池中对象，或者在将对象返回给对象池之后就不再使用它，那么就可以安全地在线程之间传递所有权。

**【↑ 这段话有点绕的，作者陈述了线程之间安全传递对象的前提，里面包含了好几个要点，需要总结出来】**

我们也可以使用其他发布机制来传递 可变对象 的所有权，**但必须确保只有一个线程能接受被转移的对象。**<---【基本条件】 阻塞队列简化了这项工作，除此之外，还可以通过 `ConcurrentMap` 的原子方法 `remove` 或者 `AtomicReference` 的原子方法 `compareAndSet` 来完成这项工作。**<---【这里只给出了结论，同样缺少了具体案例，需要我们自己进行补充】**

#### 5.3.3 双端队列与工作密取

Java 6 增加了两种容器类型 ，`Deque`（发音为  "deck"）和 `BlockingDeque` ，它们分别对 `Queue` 和 `BlockingQueue` 进行了扩展。

Deque 是一个 「双端队列」，实现了在队列头和队列尾的**高效插入和移除**【也就是高效修改操作】，具体实现包括 `ArrayDeque` 和 `LinkedBlockingDeque`。 

正如阻塞队列适用于 "生产者—消费者" 模式，所有消费者有一个共享的工作队列，而在 「工作密取」设计中，每个消费者都有各自的双端队列。**<---【从共享变为了独享】**

如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾 「秘密地获取工作」。<---【说明消费者可以获取其他消费者队列的末尾的数据】

在 「大多数时候」，消费者只访问自己的双端队列，从而极大地减少了竞争。 当工作者线程需要访问另一个队列时，它会从队列的「尾部」 而不是 「头部」获取工作，因此进一步降低了队列上的竞争程度。

「工作密取」非常适用于既是消费者，也是生产者的问题 —— 当执行某个工作时可能导致出现更多的工作。

例如： 在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有很多 图 搜索的算法，例如在 垃圾回收阶段对 堆进行标记，都可以通过 工作密取 机制来实现 「高效并行」。 当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾（或者在**工作共享设计模式**中，放入其他工作者线程队列中）。

当「双端队列」 为空时，它会在另一个线程的队列队伍查找新的任务，从而确保每个线程都保持忙碌状态。**【这个设计可以很好的提高线程的利用率】**

**【这一节的信息量很大，引入了很多数据结构和概念名词，例子却少了点，所以有很多是需要自己去寻找和探索来对文章进行补充的，因为光靠概念是没办法深入学习的，talk is cheap，但是第一遍的时候我不打算去做这件事，先过一遍，第二遍才是深度学习与精度】**



### 脑图

![3.阻塞队列与生产者—消费者模式](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200408180042.png)