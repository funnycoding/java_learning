---
layout: post
title: 《Java并发编程实战》3.对象的共享（五）安全发布
tags:
  - 读书笔记
categories:
- 《Java并发编程实战》读书笔记
-  读书笔记
abbrlink: a0d3aae7
date: 2020-03-24 20:54:14
---



- {% post_link 读书笔记/java并发编程实战/3/1 1.可见性 %} 
- {% post_link 读书笔记/java并发编程实战/3/2 2.发布与逸出 %} 
- {% post_link 读书笔记/java并发编程实战/3/3 3.线程封闭 %} 
- {% post_link 读书笔记/java并发编程实战/3/4 4.不变性 %} 
- {% post_link 读书笔记/java并发编程实战/3/5 5.安全发布 %} 

<!-- more -->	

### 3.5 安全发布

目前为止，讨论的重点是**如何确保对象不被发布**，例如让对象`封闭在线程`或**另一个对象的内部**。在某些情况下我们希望在**多个线程之间`共享`对象**，此时必须确保`安全`地进行`共享`。然而，如果只是像 `程序清单 3-14` 那样将对象引用保存到 「`公有域`」 中，那么还不足以保证**安全地发布**这个对象：

> `程序清单 3-14` 在**`没有足够同步`的情况下发布对象** （不要这么做):

```java
// 不安全的发布 将要发布的对象的引用保存在 类 public 字段中
public class StuffIntoPublic {
    public Holder holder;

    public void initialize() {
        holder = new Holder(42);
    }
}
```

这个**看似没有问题的示例**为什么会失败？在`单线程`中这个类毫无疑问是可用的，但是在`多线程环境`下，由于存在「**可见性**」问题，其他线程看到的 `Holder` 对象可能处于**不一致**的状态，即便在该对象的`构造函数`中已经正确地构建了 「**不变性条件**」。 这种不正确的发布导致`其他线程`看到**尚未创建完成的对象**。

#### 3.5.1 不正确的发布：正确的对象被破坏

一个**尚未完全创建的对象**并不拥有「**完整性**」。 某个观察该对象的`线程`将看到**对象处于不一致状态**，然后看到对象的`状态`突然发生变化，即使线程在对象「`发布`」后没有修改过它。 事实上，如果`程序清单 3-15` 中的 **Holder** 使用 `清单 3-14` 中的**不安全发布方式**，那么另一个线程在调用 `assertSanity` 时 将抛出 `AssertionError`①。

> **注解①**：问题不在于 `Holder` 类本身，而在于 `Holder` 类未被`正确地发布`。然而，如果将 `n` 声明为 `final` 类型，那么 `Holder` 将成为不可变类，从而避免出现非正确发布的问题。

> `程序清单 3-15` 由于**未被正确发布**，这个类可能出现**故障**：

```java
// Class at risk of failure if not properly published
// 不安全的发布，在多线程环境下可能会出现异常与状态不一致
// Holder.java
public class Holder {
    private int n;

    public Holder(int n) {
        this.n = n;
    }

    public void assertSanity() {
        if (n != n) {
            throw new AssertionError("This statement is false");
        }
    }
}

```

由于没有使用**同步**机制来保证 `Holder` 对象，因此将 `Holder` 称为 「**未被正确发布**」的**对象**。 在这种对象中存在**两个问题**：

- 除了**发布对象的`线程`**外，其他线程看到的 `Holder` **域** 是一个**失效的值**。因此将看到一个`空引用`或之前的`旧值`。
- **更糟糕的情况**是，`线程`看到的 `Holder` **引用的值是最新**的， 但 `Holder` **状态的值确实失效②**的。情况更加**不可预测**的是：`某个线程`在`第一次读取域`的时得到的是**失效值**，而`再次读取`这个域时会得到一个**更新的值**，这也是 `assertSanity` 可能会抛出 `AssertionError` 的原因。

> **注解②**：尽管在`构造函数`中设置的`域`值似乎是第一次向这些域中写入的值，因此不会有"`更旧`的值" 这种`失效`情况，但是 `Object` 的`构造函数`会在`子类构造函数` **运行之前**先将`默认值`写入所有的域。因此，某个域的`默认值`可能被视为是 `失效值`

如果没有**足够的同步**，在多个**线程之间共享数据**会发生一些非常奇怪的事情。

#### 3.5.2 不可变对象与初始化安全性

**不可变对象**是一种非常重要的对象。 「`Java内存模型`」为「不可变对象」提供了**特殊的初始化安全性保证**。我们之前已经知道，即使某个**对象的引用**对其他线程是可见的，也并不意味着**对象状态** 对于使用该对象的线程来说一定是可见的。【缓存带来了可见性问题】为了确保**「对象状态」**能呈现出**「一致的视图」**，就必须使用**同步**。

另一方面，即使在「**发布**」**不可变对象的引用**时没有使用`同步`，也可以安全地访问该对象。为了维持这种**初始化安全性**的保证，必须满足**不可变性**的所有需求：

- **`状态`不可修改**
- 所有**域**都是 `final` 类型。
- 正确的构造过程（如果程序清单3-15  `Holder` 对象是不可变的，那么即使没有正确发布，也不会抛出 `AssertionError` 异常。

> **任何线程**都可以在不需要额外同步的情况下安全地访问 「`不可变对象`」，即使在发布这些对象时**没有使用同步**。

这种**保证**还将`延伸`到被**正确创建对象**中所有 `final` 类型的**域**。 在没有**额外同步**的情况下，也可以安全地访问 `final` 类型的域。然而，如果 `final` 类型的域指向的是**可变对象**，那么**在访问这些域所指向的对象的状态时仍然需要`同步`**。



#### 3.5.3 安全发布的常用模式

**「可变对象」**必须通过 **「安全的方式」**来发布，这意味着 「**发布**」和「**使用**」 该对象的`线程`都必须使用**「同步」**。

下面是如何确保**使用对象的线程**能够看到该对象处于**已发布状态**，并稍后介绍如何在**发布后**对其**可见性**进行`修改`：

要**安全地发布一个对象**，**「对象的`引用`」** 以及 **「对象的`状态`」** 必须 **同时** 对其他线程可见，一个**正确构造的对象**可以通过以下方式来安全地发布：

- 在**「静态初始化函数」**中初始化一个**「对象引用」** **<---【通过 JVM 对静态变量的特殊处理机制来保证安全发布】**
- 将**「对象的引用」**保存到 `volatile` 类型的域 或者 `AtomicReference` 对象中 <---【通过 `volatile` 保证可见性，或者通过原子类 来保证对象安全发布】
- 将**对象的引用**保存到某个正确构造对象的 `final` 类型的域中。 **<---【通过不可变对象安全发布】**
- 将**对象的引用**保存到一个由 **「锁」** 保护的 域中 <---**【通过锁保证对象安全发布】**

在**「线程安全容器」**内部进行同步意味着，将对象放入到某个容器 如 `Vector` 或 `synchronizedList` 时，将满足上述最后一条需求。如果 `线程A` 将 `对象X` 放入一个**线程安全的容器**，随后`线程B` `读取`这个对象，那么可以确保 `线程B` 看到 `线程A` 设置的 X的状态，即便这段 读/写 X 的应用程序代码中没有显示的包含**显式的同步**。 

尽管 **Javadoc** 在这个主题上没有给出很清晰的说明，但是**线程安全**库中的`容器类`提供了以下的`安全发布保证`：

- 通过将一个键或值 放入 `Hashtable`、`synchronizedMap` 或者 `ConcurrentMap` 中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）
- 通过将元素放入 `Vector`、`CopyOnWriteArrayList`、`ConpyOnWriteArraySet`、`synchronizedList` 或 `synchronizedSet` 中可以将该元素安全地发布到任何从这些容器中访问该元素的线程
- 通过将某个元素放入 `BlockingQueue` 或者 `ConcurrentLinkedQueue` 中，可以将元素安全地发布到任何从这些**「队列」**中访问该线程的元素

**上面就是三类线程安全的容器。**

类库中的其他**数据传递机制** 例如 `Future` 和 `Exchanger` 同样能实现**安全发布**，在介绍这些机制时将要讨论它们的安全发布功能。

通常，要`发布`一个 **静态构造对象**， 最简单和安全的方式是使`用静态的初始化器`：

```java
// 将 new 关键字创建的对象用静态变量保存就是 使用 静态的初始化器？
public static Holder holder = new Holder(42)
```

**「静态的初始化器」**由 **JVM**  在类的**「初始化」**阶段执行（`static` 的特性）。由于 在**「JVM 内部」**存在着「**同步机制」**，因此通过这种方式初始化的任何对象都可以被安全地发布[JLS 12.4.2]。

【↑**也就是利用虚拟机的同步机制来安全发布对象。**】



#### 3.5.4 事实不可变对象（Effectively Immutable Object)

【这里的事实不可变跟 《OnJava8》中讲`函数式编程`中的**闭包特性**的**事实不可变**是一致的概念：**虽然这个变量是`非final` 修饰的，但是在这个作用域内它确实没有改变 就是事实不可变对象**】

如果对象在发布后没有被修改，那么对于其他没有在额外同步的情况下安全地访问这些对象的`线程`来说，**「安全发布」**是足够的。所有的**「安全发布机制」**都能确保，当「**对象的引用**」对所有访问该对象的`线程`可见时，对象发布时的**状态**对于所有`线程`也将是**可见**的。并且如果**对象状态不会再改变**，那么就足以确保任何线程访问都是安全的。

如果**对象从技术上来说是可变**的，但是**事实上其状态在发布后`不会再改变`**，那么将这种对象称为**事实不可变对象（Effectively Immutable Object)**。通过使用「**事实不可变对象**」可以保证安全性，简化开发过程，同时不会因为使用同步而减少性能。

> 在没有**额外同步**的情况下，`任何线程`都可以安全地使用被安全发布的 **事实不可变对象**。

例如 `Date` 本身是可变的①，但是如果将它作为**不可变对象**来使用，那么在**多个线程**之间**共享** `Date` 对象时就省去了对`锁`的使用。

> **注解①**：这或许是类库设计中的一个失误。

假设需要维护一个`Map`对象，其中保存了每位用户最近的登录时间:

```java
public Map<String,Date> lastLogin = Collections.synchronizedMap(new HashMap<String,Date>());
```

如果 `Date` 值被放入 `Map` 中之后就**不会再改变**，那么 `synchronizedMap` 中的同步机制足以使 `Date`

被安全地发布，并且在访问这些 `Date` 时不需要**额外的同步**。



#### 3.5.5 可变对象

如果**对象在构造后可以修改**，那么「**安全发布**」只能确保 "发布当时" 状态的可见性。 对于「**可变对象**」，不仅在**发布对象时需要使用同步**，而且在每次对象**访问**时同样需要使用`同步`来确保**后续操作**的「**可见性**」。要安全地`共享`「**可变对象**」，这些对象就必须被**安全地发布**，**并且必须是线程安全的，或者由某个`锁`保护起来**。

**对象的发布**需求取决于它的**可变性**：

- **不可变对象**可以使用**任意的机制来发布**。
- **事实不可变对象**必须通过**安全地方式**来发布。
- **可变对象**必须通过**安全地方式来发布**，并且**必须是`线程安全`的或者由某个`锁`保护起来**。

#### 3.5.6 安全地共享对象

当获取一个**对象的引用**时，你首先需要知道在这个**引用**上可以执行哪些操作。在使用这个引用之前是否需要获得`锁`？是否可以**修改**它的状态，或者只能**读取**它。许多**并发错误**都是没有理解**共享对象**的这些 "**既定规则**" 而导致的。当**发布一个对象时，必须明确地说明对象的访问方式**。

【也就是需要有文档性的说明来指导怎样使用对象的引用】

在**并发程序**中`使用`和`共享`对象时，可以使用一些**实用的策略**：

- **线程封闭**。 线程封闭的对象只能被一个线程持有，**对象被封闭在线程内**，没有共享就不会出现竞态条件，并且该对象只能由指定线程修改
- **只读共享**。 在没有额外同步的情况下，**共享的只读对象可以由多个线程并发访问** ，但是`任何线程都不能修改`它。共享的只读对象包括 **不可变对象** 和 **事实不可变对象**。
- **线程安全共享**。线程安全的对象在其内部实现同步。因此多个线程可以通过对象的公有接口进行访问而不需要进一步的同步
- **保护对象**。被保护的对象只能通过持有特定的`锁`进行访问。保护对象包括封装在其他线程安全对象中的对象，以及已经发布的并且由某个特定锁保护的对象。



### 思维导图

![3.对象共享](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200327160903.png)