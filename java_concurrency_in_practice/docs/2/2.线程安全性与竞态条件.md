## 《Java并发编程实战》2.线程的安全性与竞态条件

### 概念引入：

**`安全性`：程序运行总能获得正确的结果。**











`线程` 或者 `锁` 在`并发编程`中的作用，类似 `铆钉`和`工字梁`在 土木工程 中的作用。 要建筑一座坚固的桥梁，必须正确地使用大量的铆钉和工字梁。

同理，构建`稳健`的`并发程序`，必须正确地使用`「线程」`和`「锁」`。

但这些终归只是一些机制，要编写**「线程安全」**的代码，`核心`在于对 **「`状态访问`**」 的操作进行**管理**，**特别是对`「共享」`（Shared） 和 `「可变」`（Mutable）状态的访问。**



`非正式意义`上的 **对象状态** 是指：**存储在状态变量（例如`静态域` 或者 `实例`） 中的数据**。 

**对象的状态可能`包括`其他依赖对象的域**。 **例如**：某个 `HashMap` 的状态**不仅存储在 `HashMap` 对象本身**，**还存储在许多 `Map.Entry` 对象中**。 在`对象的状态`中包含了任何可能影响其`外部可见行为`的数据。

**`共享`** 意味着变量可以被**多个线程同时访问**。**`可变`** 则意味着变量的值在其`生命周期`内可以发生`变化`。我们的重点在于如何`防止`在数据上发生`不受控`的`并发访问`。

**对象是否需要是线程安全的**取决于它**`被访问的方式`**，如果它是被`多线程`访问的，那么就`不安全`。这里指的是在程序中访问对象的方式，而不是对象要实现的功能。

如果对象是`可变且共享`的，那么在`多线程环境`中，就需要使用`同步机制`来保证`状态`的`安全`，否则就会导致数据的损坏以及其他异常的发生。

**Java 中的主要同步机制：**

- `synchronized` 关键字，一个独占的加锁方式。
  - 底层实现是`内置锁`，`管程`（通用并发问题解决模型）。
- **`volatile` 类型的变量**
  - 底层实现是 `JMM Java 内存模型`。
- **`显式锁`（Explicit Lock）**
  - `JDK` 中提供的`类库`，提供和 `synchronized` 不一样的功能，解决了 `synchronized` 无法解决的 「破坏不可抢占条件」 打破死锁问题的方案，所以`重新设计`的`互斥锁`。

![image-20200721015623415](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200721015624.png)

- **`原子变量`**
  - `JDK` 中提供的现成类库，是`无锁工具类`的典范，`性能好`，`不会出现死锁问题`（但可能出现活锁和饥饿问题），使用场景针对 `「一个共享变量」`。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200721015649.png)

除了这几种，并不存在想象外的例外情况，**如果使用了多线程且`没有`使用同步机制，程序一定会在某个时刻发生错误**。

**要保证`多线程`情况下的`线程安全`，有三种情况：**

1. 线程中**`状态`**是**`不可变`**的，于是不存在状态被改变的问题 —— `不可变类`。
2. **不在线程之间「共享」状态变量** —— `变量封闭`。
3. 在访问状态的时候使用**同步**机制。

如果要**使用多线程**，**在类开始`设计`的阶段就需要将线程的安全性考虑进去**，否则`设计完成后再修改`可能需要巨大的工作量。

在某些情况下，**良好的面向对象设计技术与实际情况的需求并不一致**。在这些情况中，有时需要两相其害取其轻，`放弃`一些良好的设计原则，以`换取性能`或者`对遗留代码的向后兼容`。

`Java` 语言`并没有强制要求`将所有`「状态」`都`封装在类中`，开发人员完全可以将状态保存在某个`公开的域`（甚至`公开的静态域`）中，或者`提供`一个**内部对象**的`「公开引用」`。然而，`程序状态的封装性越好，就越容易实现程序的线程安全性，并且代码的维护人员也容越容易保持这种方式。`

**编写并发程序的`第一要务就是正确性`**：首先要让代码`正确`运行，然后`再提高`代码的速度。

有时必须`打破封装`，你`仍然`可以实现`线程的安全性`，但是会更加`困难`，而且在`打破封装`的情况下，线程的安全性将更加脆弱。增加了`开发的成本和风险`，以及`维护的成本和风险`。`第4章`介绍了哪些状态下可以安全地放宽状态变量的封装性。

在任何情况中，只有当类中仅包含自己的状态时，线程安全类才是有意义的。**线程安全性只与状态有关**，因此只能应用于封装其状态的整个代码，这可能是一个单独的对象，也可能是整个程序。


### 2.1 什么是线程安全性

给`线程的安全性`下一个`确切的定义`是`非常复杂`的，`定义越正式就越复杂`。而且这种定义很难提供有实际意义的指导建议，也很难从直观上去理解。

对`线程安全性`的定义中，其`核心概念`就是 `正确性`。

`正确性的含义`是：某个类的`「行为」`与其`「规范」` **完全一致**。

良好的规范中会定义`不变性条件`（Invariant）来**约束对象的状态**，定义`后验条件`（**Postcondition**）描述对象操作的结果。

我们将单线程程序定义为近似正确的，而`多线程`中的**线程安全性**是：当多个线程访问某个类时，这个类始终都能表现出正确的行为，这个类就是线程安全的。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式，或者这些线程将如何交替执行，并且在**`主调代码`**中不需要任何`额外的同步或协同`，这个类都能表现出**正确的行为**，**那么就称这个类是线程安全的。**

**「单线程程序」**也可以看成是一个 **「多线程程序」**，如果某个类在`单线程`环境下都不是正确的，那么它肯定不是线程安全的。如果正确地实现了某个对象，那么在任何操作中（包括`调用对象的公有方法`或对其**公有域**进行 `读/写` 操作）都不会违背 `「不变性条件」` 或 `「后验条件」`。

在**线程安全的类的对象实例**上执行任何`串行`或`并行`操作都`不会`使对象处于**无效状态**。

> 示例：一个 **无状态** 的 `Serlvet` ：

```java
/**
 * @author XuYanXin
 * @program javaconcurrency_learn
 * @description 一个线程安全的 Servlet 因为这个类不存在状态（类实例域，静态域） 只是在方法内对参数进行处理
 * @date 2020/3/20 2:39 下午
 */

@ThreadSafe
public class StatelessFactorizer extends GenericServlet implements Servlet {


    @Override
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }

    private void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {

    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        return new BigInteger[]{i};
    }


}

```

与大多数 `Servlet` 相同，`StateLessFactorizer` 是**无状态**的：该类中不包含任何字段，也不包含任何对其他类中字段的引用。计算过程中的临时状态仅存在于 `线程栈` 上的 `局部变量`中，并且该局部变量只能由 正在执行 的线程访问。

访问 `StatelessFactorizer` 的线程不会影响另一个访问同一个 `StatelessFactorizer` 的线程的 `「计算结果」`，因为这两个线程`不存在`**「共享状态」**，就**好像它们都在访问不同的实例一样**。

由于线程访问`无状态对象`的行为并**不会影响 **`其他线程`中操作的正确性，因此**「无状态对象」** 是`线程安全`的。

大多数 `Servlet` 都是**无状态**的，从而极大降低了`Servlet` 线程安全性的复杂性。 只有当 `Servlet` 在处理请求时需要 `「保存一些信息」` 时，**线程安全性才会成为一个问题**。

**【上面的例子也印证了三大线程安全情况的第一种：不存在共享变量时，线程是安全的】**

### 2.2 原子性

当我们在 `无状态` 对象中增加一个状态时，会发生什么情况？ 如下面例子，给上面的 无状态 `Servlet` 增加一个 「命中计数器」 来统计所处理的请求数量，每处理一个请求就将这个计数器加一。

> `程序清单 2-2` 在`没有同步`的情况下统计已处理请求数量的 `Servlet`（不要这样做）

```java
@NotThreadSafe
public class UnsafeCountingFactorizer extends GenericServlet implements Servlet {
    // 定义了一个变量计数器
    private long count = 0
      
    @Override
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        // 对 count 进行递增是一个非原子操作，存在竞态条件
        ++count;
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

`UnsafeCountingFactorizer`是非线程安全的，尽管这个类在`「单线程」`环境中能正确运行。

与 `UnsafeSequence` 一样，这个类可能会 「`丢失`」 一些更新操作，虽然递增操作 `++count` 看起来在语言层面是原子的，但是这个在 Java 中只有一行的操作对应了`3个` `CPU` 指令：

1. 读取 `count` 的值 
2.  修改 `count` 的值 
3.  写入 `count` 的值"。

并且最终的结果`依赖`于之前的状态，所以这个类中存在**`竞态条件`**问题。



这里使用`极客时间`中关于原子性问题的说明图：

![img](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200516095436.png)

如果这里不是计数器，而是返回`不可重复的ID或对象标识符`，那么这个程序就可能给多个`Servlet` 返回相同的ID 而导致`严重`问题。

在并发编程中由于`不恰当的执行时序`而出现**不正确的结果**是一种**非常重要**的情况，它有一个正式的名字：「**竞态条件**」。

`并发编程网`给 **「竞态条件」** 下的定义是：

> 当两个线程`竞争`同一资源时，如果对资源的`访问顺序`敏感，就称为`竞态条件`。
>
> 导致`竞态条件`发生的代码称为：`「临界区」`。



#### 2.2.1 竞态条件

在 `UnsafecountingFactorizer` 中`存在`多个**竞态条件**，从而使**结果**变得`不可靠`。当某个计算的`正确性`取决于`多个线程`的交替执行`时序`时，就会发生竞态条件。 换句话说，结果的正确性取决于`运气`①（因为线程执行时序无法保证）。 

最常见的**竞态条件**类型：**先检查后执行（Check-Then-Act）**，即通过一个可能是**错误/失效**的值进行下一步动作。

**注解①的解释：**

> 竞态条件 这个术语很容易和另外一个相关术语 「`数据竞争`（Data Race）」混淆。 
>
> `数据竞争`：在访问`「共享的」` `非 final` 类型的域时**没有采用** `同步` 来进行 协同，那么就会出现数据竞争。
>
> 当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量并且这两个线程之间没有使用同步时，就可能出现 「数据竞争」。
>
> 在 `Java 内存模型`中，如果在代码中存在 「数据竞争」，那么这段代码就没有确定的`语义`。
>
> **并非所有的竞态条件都是数据竞争，同样并非所有的数据竞争都是竞态条件**，但是这两者都可能使并发程序`失败`。
>
> 在 `UnfacecountingFactorizer` 中**既存在竞态条件，又存在数据竞争**。
>
> `16章`会更详细的描述数据竞争的内容。

这里书中给出了一个`现实中`的例子：

> 假如你和你的朋友约定`12点`在一条大街上的星巴克会面，但是你到了之后发现那里有`两家`星巴克，你去了其中一家并在`12：10`时没有看到你朋友，那么这时你可能会去 `星巴克B` 看看他是否在那里。
>
> **如果他也不在那里，那么有以下几种可能：**
>
> - 你朋友迟到了，他现在`不在`任何一家星巴克中
> - 你朋友在你离开星巴克A后到了星巴克A
> - 你朋友先到了星巴克B，随后去星巴克A找你， 并且此时正在去星巴克A的路上。
>
> 假设`最糟糕`的情况：
>
> 现在是 12：15。你们两个都去过了两家星巴克，并且都怀疑对方是否失约了，此时你会怎么做？回到另一家星巴克吗？此时除非你们约定了某种协议，否则将在这两家星巴克之间来回打转。

【就不能打个电话吗？所以通信有多重要不言而喻】

> "我去看看他是否在另一家星巴克"这种解决问题的方法在于，当你在街上走时，你的朋友可能已经离开了你要去的星巴克（类比`状态失效`）。
>
> 你首先去了星巴克A 发现他不在，然后你做出了去星巴克B 找他的决定。 到了星巴克B 后你可以做同样的选择，但是这个选择不能同时发生，两家星巴克之间有几分钟的路程，而就在这几分钟的时间里，系`统的状态可能发生了变化`。



在上面这`个「星巴克」` 示例中说明了一种 `「竞态条件」`：要获得正确的结果（与朋友碰面）必须取决于`事件发生的时序`（当你们到达星巴克时，在离开并去另一家星巴克之前会等待多长时间）。

当你迈出前门时，你在星巴克A 的观察结果将变得无效，你的朋友可能从后门进来了，而你却不知道。

这种**观察结果的失效** 就是**大多数竞态条件的本质** —— 基于一种可能失效的观察结果做出了某种判断或某个计算。

这种类型的`「竞态条件」`称为`先检查后执行`：程序中首先观察到一个结果为`真`（某文件X不存在）于是根据这个结果进行下一步动作（创建文件X），`但是在观察到这个结果 和 进行下一步动作之间`，这个**「结果」**失效了，可能别的线程已经创建了文件X，从而`导致各种问题`（未预期的异常、数据被覆盖、文件被破坏等）。

#### 2.2.2 延迟初始化中的竞态条件

使用**先检查后执行**的一种**`常见情况`**就是**「延迟初始化」**，其目的是将对象的初始化操作`推迟`到`实际被使用时`才进行，同时确保`只初始化一次`。**【单例模式就是其中的一种应用】**

`程序清单2-3`的`LazyInitRace` 说明了这种延迟初始化的情况。  `getInstance` 方法首先`判断` `ExpensiveObject` 是否已经被初始化，**如果已经初始化则返回现有的实例**，**否则创建一个新实例并返回一个引用**，使后面执行的代码无需反复执行高成本的初始化操作。

> `程序清单2-3` 延迟初始化中的 **`竞态条件`**：

```java
// 一个典型的 线程不安全的 最简单的单例模式的实现
//LazyInitRace.java
class ExpensiveObject {

}
@NotThreadSafe
public class LazyInitRace {
    // 并不直接初始化，而是当真正使用的时候再对这个引用进行初始化
    private ExpensiveObject instance = null;
		// 判断 instance 是否被初始化，如果已经指向堆中一个对象则直接返回，否则调用构造函数
    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

**【其实这就是一个最简单的 单例模式的实现，并且这个类是非线程安全的。】**

在`LazyInitRace` 中存在一个`竞态条件`，可能会破坏这个类的正确性：假如 `线程A` 和 `线程B` 同时执行 `getInstance` 方法， A 看到 `instance` 为空，于是创建了一个新的 `ExpensiveObject` 实例。 此时的 `instance` 是否为空，要取决于 不可预测的`「时序」`，包括：

- 线程`调度`的方式
- A 需要花多长时间初始化 `ExpensiveObject` 并将其赋值给 `instance` 引用。

如果 B 看到 `instance` 的状态仍然为空，此时可能 A正在创建 `ExpensiveObject` 对象，但是 B 仍然会创建`ExpensiveObject` 对象，那么两次调用 `getInstance` 可能得到不同的结果，尽管我们认为 `getInstance` 应该返回**相同的实例**。

如果`2个线程`同时调用 `getInstance()` 方法，两个线程观察到 `instance` 此时不存在，则会通过2个线程 同时调用 `getInstance()` 最终创建2个对象， `这2次调用时可能会得到不同的结果`（**创建对象的过程中可能某些变量发生了改变，导致创建的对象有问题**）。

在 `UnsafeCountingFactorizer` 中存在的是`另一种形式的竞态条件`："`读取`——`修改`——`写入`" 这种操作需要基于对象之前的状态来定义对象状态的转换，对计数器做递增，你必须知道它之前的值，并确保在执行更新操作的过程中没有其他线程修改这个值。

与大多数并发错误一样，**竞态条件并不是总会产生错误**，还需要某种**不恰当的执行时序**。反过来说，不出错也需要依赖特定的执行时序，而执行时序是不确定的。但是竞态条件可能产生很`严重的错误`：

- `LazyInitRace` 中被用于初始化应用程序范围内的注册表，如果多次调用返回了**不同的实例**，那么要么丢失部分信息，要么多个行为对同一组注册对象表现出`不一致的视图`。 
-  `UnsafeSequence` 用于在某个 持久化框架中生成对象标识，那么两个不同的对象可能获得相同的标识，这违反了标识的**完整性约束条件**。



#### 2.2.3 复合操作

`LazyInitRace` 和 `UnsafeCountingFactorizer` 都包含一组需要以 `「原子」`方式（不可分割）执行的操作。要避免**`竞态条件`**问题，就必须**在某个线程修改变量时，通过某种方式防止其他线程使用这个变量**，从而确保其他线程只能在修改操作完成`之前`或`之后` 「`读取`」 和 「`修改`」 状态，而不是在线程修改状态过程中对状态进行操作。

**【以上这段话的核心就是 `「互斥」`】**



**原子操作的定义：有2个操作`A`和`B`，在执行A的线程来看，执行B操作的线程`要么完全不执行，要么全部执行完`，那么A和B彼此来说就是原子的。**



如果 `UnsafeCountingFactorizer` 中的 计数器递增是 「`原子操作`」 那么 `图 1-1` 中的`竞态条件`就不会发生，并且递增操作在每次执行时都会把计数器加1.

为了确保线程安全性，`2.3节` 中将介绍`「加锁机制」`，这是 `Java`用于确保原子性的 `「内置机制」`。

下面使用一个`原子类`来修复之前的竞态问题。

![image-20200516210901685](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200516210903.png)



> `程序清单 2-4` 使用 `AtomicLong` 类型的变量来统计已处理请求的数量：

```java
// CountingFactorizer.java
// 使用原子操作类 代替了不安全的基本类型 ++
public class CountingFactorizer extends GenericServlet implements Servlet {
    // 原子的Long类型
    private final AtomicLong count = new AtomicLong(0);

    // 线程安全的 get() 方法
    public long getCount() {
        return count.get();
    }

    @Override
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        // 代替了 count++ ,这里的 count.incrementAndGet() 是一个原子的增加操作。
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return null;
    }

    BigInteger[] factor(BigInteger i) {
        return null;
    }
}

```

在 `java.util.concurrent.atmoic`包中包含了一些 `JDK` 实现的原子变量类，用于实现在「`数值`」 和 「`对象引用`」 上的原子状态转换。通过用 `原子类AtomicLong` 来代替 基`础数据类型 long` 类型的计数器，能够`确保`所有对`计数器状态的访问操作都是原子`的。

由于 `Servlet 的状态`就是 `计数器的状态`（类中的 `count` 实例字段），所以只要 计数器是线程安全的，那么这里的 `Servlet` 就是线程安全的。

> 实际开发中，尽量使用`现有的` **线程安全对象**（比如 `JDK 并发包`中提供的原子类 `Atomic`）来**管理类的状态**。与非线程安全的对象相比，判断线程安全对象的可能状态以及其状态的转换要更加容易，也更容易维护和验证线程安全性。

**【这里的 `incrementAndGet()` 就是将之前的 "「读取—修改—写入」" 3个操作变为了一个整体的原子操作，所以不再存在竞态条件。】**



### 本章小结：

首先介绍了 Java 中的几种同步机制，但是只是简单的提了一下，比如`内置锁`，`volatile`，`显式锁`。

定义了什么是**`竞态条件`**，以及竞态条件产生的常见场景："`先检查后执行`"。

后面提出了一个多线程情况中会出问题的复合操作引出了**`原子性`**的重要性，然后使用一个原子类解决了这个问题。

提出了**`线程安全性`**的定义，以及怎样确保线程安全性。

总的来说本章的套路基本是 **"提出定义——引出问题——解决问题——总结方法"**。

